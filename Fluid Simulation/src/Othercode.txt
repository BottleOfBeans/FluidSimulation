    public Liquid(){

        //Initialize the Liquid!
        for(int y = 0; y < yCells; y++){
            for(int x = 0; x < xCells; x++){
                
                emptyFloat[y][x] = 0.0f;
            
                //Zero out all the components!
                u[y][x] = 0.0f;
                v[y][x] = 0.0f;
                newU[y][x] = 0.0f;
                newV[y][x] = 0.0f;
                d[y][x] = 0.0f;
                s[y][x] = 1;

                //Set up the Cells!
                cells[y][x] = new Rectangle2D.Float(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                colors[y][x] = Color.gray;

                /*
                 * Special Cases!
                 */
                
                //Add Container

                int radius = 10;

                Vector2 centerPos = new Vector2(xCells/2, yCells/2);
                Vector2 currentPos = new Vector2(x,y);
                if(currentPos.subtract(centerPos).magnitude() < radius){
                    s[y][x] = 0;
                }

                //Check if a Boundary
                if(y == 0 || x == 0 || y == yCells-1 || x == xCells-1){
                    s[y][x] = 0; // Set the scalar value to show that it is a wall. 
                    colors[y][x] = Color.DARK_GRAY;
                }

            }
        }
        
        //Setup Scene

        if(SCENE == 0){
            GRAVITY = -9.8f;
        }
        if(SCENE == 1){
            GRAVITY = 0.0f;
        }
    }    

    /*
     * Starting from Scratch, Iteration 22
     */

    public void addForces(float dt){

        for(int y = 1 ; y < yCells - 1; y++){
            for(int x = 1; x < xCells - 1; x++){

                if(SCENE == 0){
                    v[y][x] += GRAVITY * dt;
                }
                if(SCENE == 1){
                    ;
                }

            }
        }
        
    }
    
    public void solveCompression(float dt) {
        
        float pressureConst = DENSITY * cellHeight / dt;
    
        for (int i = 0; i < ITER; i++) {
            for (int y = 1; y < yCells - 1; y++) {
                for (int x = 1; x < xCells - 1; x++) {
                    if (s[y][x] == 0) continue; // Skip walls
    
                    int sLeft = s[y][x - 1];
                    int sRight = s[y][x + 1];
                    int sUp = s[y - 1][x];
                    int sDown = s[y + 1][x];
    
                    int sSum = sLeft + sRight + sUp + sDown;
    
                    if (sSum == 0) continue; // Skip fully surrounded cells
    
                    // Calculate divergence
                    float divergence = (u[y][x + 1] - u[y][x]) + (v[y + 1][x] - v[y][x]);
    
                    // Adjust pressure
                    float pressure = -divergence / sSum;
                    pressure *= OVER_RELAX_CONST;
    
                    p[y][x] += pressureConst * pressure;
    
                    // Update velocities
                    u[y][x] -= sLeft * pressure;
                    u[y][x + 1] += sRight * pressure;
                    v[y][x] -= sDown * pressure;
                    v[y + 1][x] += sUp * pressure;
                }
            }
        }

    }
    public void boundaryFix(float dt) {
        // Horizontal velocity (u) boundaries
        for (int y = 0; y < yCells; y++) {
            u[y][0] = u[y][1]; // Left boundary
            u[y][xCells - 1] = u[y][xCells - 2]; // Right boundary
            
        }
    
        // Vertical velocity (v) boundaries
        for (int x = 0; x < xCells; x++) {
            v[0][x] = v[1][x]; // Top boundary
            v[yCells - 1][x] = v[yCells - 2][x]; // Bottom boundary
        }
    }

    public float sampleField(float x, float y, String type) {
        // Lock down the boundaries
        x = Math.max(0, Math.min(x, (xCells - 1) * cellWidth));
        y = Math.max(0, Math.min(y, (yCells - 1) * cellHeight));
    
        float dx, dy;
        float[][] sampleField;
    
        switch (type) {
            case "UFIELD":
                // U values are stored at the middle of vertical edges (staggered in x)
                dx = 0.0f; // Offset in x-direction
                dy = 0.5f; // No offset in y-direction
                sampleField = u;
                break;
    
            case "VFIELD":
                // V values are stored at the middle of horizontal edges (staggered in y)
                dx = 0.5f; // No offset in x-direction
                dy = 0.0f; // Offset in y-direction
                sampleField = v;
                break;
            case "DFIELD":
                // V values are stored at the middle of horizontal edges (staggered in y)
                dx = 0.5f; // No offset in x-direction
                dy = 0.5f; // Offset in y-direction
                sampleField = d;
            break;

            default:
                System.out.println("NOT A CORRECT FIELD VALUE");
                return 0.0f;
        }
    
        // Adjust the position for staggered grid
        float staggeredX = x - dx * cellWidth;
        float staggeredY = y - dy * cellHeight;
    
        // Calculate the grid cell indices
        int xPos = (int) (staggeredX / cellWidth);
        int yPos = (int) (staggeredY / cellHeight);
    
        // Clamp the indices to stay within the grid boundaries
        xPos = Math.max(1, Math.min(xPos, xCells - 2));
        yPos = Math.max(1, Math.min(yPos, yCells - 2));
    
        // Calculate the fractional part within the cell
        float i = (staggeredX % cellWidth) / cellWidth;
        float j = (staggeredY % cellHeight) / cellHeight;
    
        // Perform bilinear interpolation
        float q11 = sampleField[xPos][yPos];
        float q12 = sampleField[xPos][yPos + 1];
        float q21 = sampleField[xPos + 1][yPos];
        float q22 = sampleField[xPos + 1][yPos + 1];
    
        float r1 = q11 * (1 - i) + q21 * i; // Interpolate along x-axis
        float r2 = q12 * (1 - i) + q22 * i; // Interpolate along x-axis
        float result = r1 * (1 - j) + r2 * j; // Interpolate along y-axis
    
        return result;
    }
    
    public float averageU(int x, int y){
        return (u[y - 1][x] + u[y][x] + u[y - 1][x + 1] + u[y][x + 1]) * 0.25f;
    }
    public float averageV(int x, int y){
        return (v[y][x - 1] + v[y][x] + v[y + 1][x - 1] + v[y + 1][x]) * 0.25f;
    }

    public void advectVelocities(float dt) {
        for (int y = 1; y < yCells - 1; y++) {
            for (int x = 1; x < xCells - 1; x++) {
                if (s[y][x] == 0) continue; // Skip walls
    
                if(s[y][x - 1] != 0){
                    // Advect horizontal velocity (u)
                    float xPosU = x * cellWidth;
                    float yPosU = (y + 0.5f) * cellHeight;
        
                    float uVel = u[y][x];
                    float vVel = averageV(x, y);
        
                    xPosU -= uVel * dt;
                    yPosU -= vVel * dt;

                    newU[y][x] = sampleField(xPosU, yPosU, "UFIELD");
                }
    
    
                if(s[y - 1][x] != 0){
                    // Advect vertical velocity (v)
                    float xPosV = (x + 0.5f) * cellWidth;
                    float yPosV = y * cellHeight;
        
                    float uVel = averageU(x, y);
                    float vVel = v[y][x];
        
                    xPosV -= uVel * dt;
                    yPosV -= vVel * dt;
        
                    newV[y][x] = sampleField(xPosV, yPosV, "VFIELD");
                }

            }
        }
    
        // Update velocities
        u = newU.clone();
        v = newV.clone();

    }

    public void advectDensity(float dt) {
        // Temporary array to store the new density values
        newD = new float[yCells][xCells];
    
        // Half cell width and height for staggered grid
        float h2x = cellWidth * 0.5f;
        float h2y = cellHeight * 0.5f;
    
        for (int y = 1; y < yCells - 1; y++) {
            for (int x = 1; x < xCells - 1; x++) {
                if (s[y][x] == 0) continue; // Skip walls
    
                // Calculate the velocity at the cell center
                float uVel = (u[y][x] + u[y][x + 1]) * 0.5f; // Average horizontal velocity
                float vVel = (v[y][x] + v[y + 1][x]) * 0.5f; // Average vertical velocity
    
                // Calculate the previous position using backward tracing
                float xPos = (x + 0.5f) * cellWidth - uVel * dt * densitySpeedScale;
                float yPos = (y + 0.5f) * cellHeight - vVel * dt * densitySpeedScale;
    
                // Sample the density at the previous position
                newD[y][x] = sampleField(xPos, yPos, "DFIELD");
            }
        }
    
        // Update the density field
        d = newD.clone();
    }
    
    public void addDensity(float dt){
        
        if(SCENE == 0){ //GRAVITY TANK
            for(int x = 40; x < 60; x++){
                d[yCells-2][x] += 25.0f;
            }
        }         
    }
    
    public void updateLiquid(double deltaTime){
        float dt = (float) deltaTime;

        //1. Add Forces
        addForces(dt);
        addDensity(dt);

        p = emptyFloat.clone();
        solveCompression(dt);

        boundaryFix(dt);

        advectVelocities(dt);
        advectDensity(dt);

        densityColorUpdate();
    }
    
    
    
    
    //Visualization Code!    

    public void pressureColorUpdate(){
        // Assuming pMin and pMax are the minimum and maximum pressure values in the grid
        float pMin = Float.MAX_VALUE;
        float pMax = Float.MIN_VALUE;

        // First pass to find the min and max pressure values
        for (int y = 0; y < yCells; y++) {
            for (int x = 0; x < xCells; x++) {
                if (s[y][x] != 0) {
                    pMin = Math.min(pMin, p[y][x]);
                    pMax = Math.max(pMax, p[y][x]);
                }
            }
        }

        // Second pass to update colors based on normalized pressure
        for (int y = 0; y < yCells; y++) {
            for (int x = 0; x < xCells; x++) {
                if (s[y][x] == 0) {
                    continue; // Skip cells with no fluid
                }

                // Normalize pressure to [0, 1] range
                float normalizedPressure = (p[y][x] - pMin) / (pMax - pMin);

                // Map normalized pressure to color range [0, 255]
                int red = (int) (255 * normalizedPressure);
                int blue = 255 - red;
                int green = 0; // Or adjust based on your needs

                // Ensure color values are within [0, 255]
                red = Math.min(255, Math.max(0, red));
                blue = Math.min(255, Math.max(0, blue));
                green = Math.min(255, Math.max(0, green));

                colors[y][x] = new Color(red, green, blue);
            }
        }
    }
   
    public void densityColorUpdate() {
        // Initialize min and max density values
        float dMin = Float.POSITIVE_INFINITY;
        float dMax = Float.NEGATIVE_INFINITY;
    
        // First pass to find the min and max density values
        for (int y = 0; y < yCells; y++) {
            for (int x = 0; x < xCells; x++) {
                if (s[y][x] != 0) { // Only consider fluid cells
                    dMin = Math.min(dMin, d[y][x]);
                    dMax = Math.max(dMax, d[y][x]);
                }
            }
        }
    
        // Handle the case where all density values are the same
        if (dMax == dMin) {
            dMax = dMin + 1; // Avoid division by zero
        }
    
        // Second pass to update colors based on normalized density
        for (int y = 0; y < yCells; y++) {
            for (int x = 0; x < xCells; x++) {
                if (s[y][x] == 0) {
                    continue; // Skip cells with no fluid
                }
    
                // Normalize density to [0, 1] range
                float normalizedDensity = (d[y][x] - dMin) / (dMax - dMin);
    
                // Map normalized density to color range [0, 255]
                int red = (int) (255 * normalizedDensity);
                int blue = 255 - red;
                int green = (int) (red / 3); // Adjust green based on red
    
                // Ensure color values are within [0, 255]
                red = Math.min(255, Math.max(0, red));
                blue = Math.min(255, Math.max(0, blue));
                green = Math.min(255, Math.max(0, green));
    
                // Set the color for the cell
                colors[y][x] = new Color(red, green, blue);
            }
        }
    }
    
    public void combinedColorUpdate(){
        float dMin = Float.MAX_VALUE;
        float dMax = Float.MIN_VALUE;
        float pMin = Float.MAX_VALUE;
        float pMax = Float.MIN_VALUE;


        // First pass to find the min and max pressure values
        for (int y = 0; y < yCells; y++) {
            for (int x = 0; x < xCells; x++) {
                if (s[y][x] != 0) {
                    dMin = Math.min(dMin, d[y][x]);
                    dMax = Math.max(dMax, d[y][x]);
                    pMin = Math.min(dMin, d[y][x]);
                    pMax = Math.max(dMax, d[y][x]);

                }
            }
        }

        // Second pass to update colors based on normalized pressure
        for (int y = 0; y < yCells; y++) {
            for (int x = 0; x < xCells; x++) {
                if (s[y][x] == 0) {
                    continue; // Skip cells with no fluid
                }

                // Normalize pressure to [0, 1] range
                float normalizedPressure = (d[y][x] - dMin) / (dMax - dMin);

                // Map normalized pressure to color range [0, 255]
                int red = (int) (255 * normalizedPressure);
                int blue = 255 - red;
                int green = 0; // Or adjust based on your needs

                // Ensure color values are within [0, 255]
                red = Math.min(255, Math.max(0, red));
                blue = Math.min(255, Math.max(0, blue));
                green = Math.min(255, Math.max(0, green));

                float normalizedDensity = (p[y][x] - pMin) / (pMax - pMin);

                // Map normalized pressure to color range [0, 255]
                red += (int) (255 * normalizedDensity);
                blue += 255 - red;
                green += 0; // Or adjust based on your needs

                red /= 2;
                blue /=2;
                green /=2;

                // Ensure color values are within [0, 255]
                red = Math.min(255, Math.max(0, red));
                blue = Math.min(255, Math.max(0, blue));
                green = Math.min(255, Math.max(0, green));


                colors[y][x] = new Color(red, green, blue);
            }
        }

    }

    public Rectangle2D getCell(int i,int j){
        return cells[i][j];
    }
    public Color getColor(int i, int j){
        return colors[i][j];
    }
    public int getHeight(){
        return yCells;
    }
    public int getWidth(){
        return xCells;
    }

    public Line2D getHorizontalLine(int i, int j) {
        float StartingPointX = (float) cells[i][j].getCenterX() - cellWidth/2;
        float StartingPointY = (float) cells[i][j].getCenterY();
        return new Line2D.Double(StartingPointX, StartingPointY, StartingPointX + u[i][j] * VECTOR_LINE_SCALE, StartingPointY);
    }
    public Line2D getVerticalLine(int i, int j) {
        float StartingPointX = (float) cells[i][j].getCenterX();
        float StartingPointY = (float) cells[i][j].getCenterY() - cellHeight/2;
        return new Line2D.Double(StartingPointX, StartingPointY, StartingPointX, StartingPointY + v[i][j] * VECTOR_LINE_SCALE);
    }

    public void drawStreamlines(Graphics2D g) {
        
        int streamAmount = 20;
        int streamLength = 5;
    
        // Precompute step sizes
        int xStep = GameWindow.gameWidth / streamAmount;
        int yStep = GameWindow.gameHeight / streamAmount;
    
        // Precompute bounds
        int maxXCell = xCells - 1;
        int maxYCell = yCells - 1;
    
        // Temporary variables to avoid object creation in the loop
        float sx, sy;
        int xPos, yPos;
    
        for (int x = 0; x < GameWindow.gameWidth; x += xStep) {
            for (int y = 0; y < GameWindow.gameHeight; y += yStep) {
                sx = x;
                sy = y;
    
                for (int i = 0; i < streamLength; i++) {
                    xPos = (int) (sx / cellWidth);
                    yPos = (int) (sy / cellHeight);
    
                    // Clamp xPos and yPos within bounds
                    xPos = Math.min(maxXCell, Math.max(0, xPos));
                    yPos = Math.min(maxYCell, Math.max(0, yPos));
    
                    // Draw the streamline segment
                    g.drawLine((int) sx, (int) sy, (int) (sx + u[yPos][xPos]), (int) (sy + v[yPos][xPos]));
    
                    // Update the position
                    sx += u[yPos][xPos];
                    sy += v[yPos][xPos];
                }
            }
        }
    }
}
